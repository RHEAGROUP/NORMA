using System;
using System.Collections.Generic;
using Microsoft.VisualStudio.VirtualTreeGrid;
using ORMSolutions.ORMArchitect.Core.ObjectModel;
using ORMSolutions.ORMArchitect.Framework.Shell.DynamicSurveyTreeGrid;
using ORMSolutions.ORMArchitect.Framework;
using Microsoft.VisualStudio.Modeling;
using ORMSolutions.ORMArchitect.Framework.Shell;
using System.ComponentModel.Design;
using Microsoft.VisualStudio.Modeling.Shell;
using System.Collections.ObjectModel;
using System.ComponentModel;
using org.semanticweb.owlapi.model;
using org.semanticweb.owlapi.reasoner;
using org.semanticweb.owlapi.reasoner.impl;

namespace unibz.ORMInferenceEngine
{
	partial class InferredSubsetConstraint : IAnswerSurveyQuestion<SurveyRootElementType>, IAnswerSurveyQuestion<SurveyElementType>
	{
		#region IAnswerSurveyQuestion<SurveyRootElementType> Implementation
		int IAnswerSurveyQuestion<SurveyRootElementType>.AskQuestion(object contextElement)
		{
			return (int)SurveyRootElementType.InferredConstraint;
		}
		#endregion // IAnswerSurveyQuestion<SurveyRootElementType> Implementation
		#region IAnswerSurveyQuestion<SurveyElementType> Implementation
		// We override this Question in order to prevent inferred constraints appear in the external constraints groups
		// We now have to provide answers to put them under our top level group
		int IAnswerSurveyQuestion<SurveyElementType>.AskQuestion(object contextElement)
		{
			return -1;
		}
		#endregion // IAnswerSurveyQuestion<SurveyElementType> Implementation
	}
	partial class InferredEqualityConstraint : IAnswerSurveyQuestion<SurveyRootElementType>, IAnswerSurveyQuestion<SurveyElementType>
	{
		#region IAnswerSurveyQuestion<SurveyRootElementType> Implementation
		int IAnswerSurveyQuestion<SurveyRootElementType>.AskQuestion(object contextElement)
		{
			return (int)SurveyRootElementType.InferredConstraint;
		}
		#endregion // IAnswerSurveyQuestion<SurveyRootElementType> Implementation
		#region IAnswerSurveyQuestion<SurveyElementType> Implementation
		// We override this Question in order to prevent inferred constraints appear in the external constraints groups
		// We now have to provide answers to put them under our top level group
		int IAnswerSurveyQuestion<SurveyElementType>.AskQuestion(object contextElement)
		{
			return -1;
		}
		#endregion // IAnswerSurveyQuestion<SurveyElementType> Implementation
	}
	partial class InferredExclusionConstraint : IAnswerSurveyQuestion<SurveyRootElementType>, IAnswerSurveyQuestion<SurveyElementType>
	{
		#region IAnswerSurveyQuestion<SurveyRootElementType> Implementation
		int IAnswerSurveyQuestion<SurveyRootElementType>.AskQuestion(object contextElement)
		{
			return (int)SurveyRootElementType.InferredConstraint;
		}
		#endregion // IAnswerSurveyQuestion<SurveyRootElementType> Implementation
		#region IAnswerSurveyQuestion<SurveyElementType> Implementation
		// We override this Question in order to prevent inferred constraints appear in the external constraints groups
		// We now have to provide answers to put them under our top level group
		int IAnswerSurveyQuestion<SurveyElementType>.AskQuestion(object contextElement)
		{
			return -1;
		}
		#endregion // IAnswerSurveyQuestion<SurveyElementType> Implementation
	}

	partial class InferredMandatoryConstraint : IAnswerSurveyQuestion<SurveyRootElementType>, IAnswerSurveyQuestion<SurveyElementType>
	{
		#region IAnswerSurveyQuestion<SurveyRootElementType> Implementation
		int IAnswerSurveyQuestion<SurveyRootElementType>.AskQuestion(object contextElement)
		{
			return (int)SurveyRootElementType.InferredConstraint;
		}
		#endregion // IAnswerSurveyQuestion<SurveyRootElementType> Implementation
		#region IAnswerSurveyQuestion<SurveyElementType> Implementation
		// We override this Question in order to prevent inferred constraints appear in the external constraints groups
		// We now have to provide answers to put them under our top level group
		int IAnswerSurveyQuestion<SurveyElementType>.AskQuestion(object contextElement)
		{
			return -1;
		}
		#endregion // IAnswerSurveyQuestion<SurveyElementType> Implementation
	}
	partial class InferredFrequencyConstraint : IAnswerSurveyQuestion<SurveyRootElementType>, IAnswerSurveyQuestion<SurveyElementType>
	{
		#region IAnswerSurveyQuestion<SurveyRootElementType> Implementation
		int IAnswerSurveyQuestion<SurveyRootElementType>.AskQuestion(object contextElement)
		{
			return (int)SurveyRootElementType.InferredConstraint;
		}
		#endregion // IAnswerSurveyQuestion<SurveyRootElementType> Implementation
		#region IAnswerSurveyQuestion<SurveyElementType> Implementation
		// We override this Question in order to prevent inferred constraints appear in the external constraints groups
		// We now have to provide answers to put them under our top level group
		int IAnswerSurveyQuestion<SurveyElementType>.AskQuestion(object contextElement)
		{
			return -1;
		}
		#endregion // IAnswerSurveyQuestion<SurveyElementType> Implementation
	}
	partial class InferredUniquenessConstraint : IAnswerSurveyQuestion<SurveyRootElementType>, IAnswerSurveyQuestion<SurveyElementType>
	{
		#region IAnswerSurveyQuestion<SurveyRootElementType> Implementation
		int IAnswerSurveyQuestion<SurveyRootElementType>.AskQuestion(object contextElement)
		{
			return (int)SurveyRootElementType.InferredConstraint;
		}
		#endregion // IAnswerSurveyQuestion<SurveyRootElementType> Implementation
		#region IAnswerSurveyQuestion<SurveyElementType> Implementation
		// We override this Question in order to prevent inferred constraints appear in the external constraints groups
		// We now have to provide answers to put them under our top level group
		int IAnswerSurveyQuestion<SurveyElementType>.AskQuestion(object contextElement)
		{
			return -1;
		}
		#endregion // IAnswerSurveyQuestion<SurveyElementType> Implementation
	}

	partial class InferredSubtypeFact : IAnswerSurveyQuestion<SurveyRootElementType>, IAnswerSurveyQuestion<SurveyElementType>
	{
		#region IAnswerSurveyQuestion<SurveyRootElementType> Implementation
		int IAnswerSurveyQuestion<SurveyRootElementType>.AskQuestion(object contextElement)
		{
			return (int)SurveyRootElementType.InferredConstraint;
		}
		#endregion // IAnswerSurveyQuestion<SurveyRootElementType> Implementation
		#region IAnswerSurveyQuestion<SurveyElementType> Implementation
		// We override this Question in order to prevent inferred constraints appear in the external constraints groups
		// We now have to provide answers to put them under our top level group
		int IAnswerSurveyQuestion<SurveyElementType>.AskQuestion(object contextElement)
		{
			return -1;
		}
		#endregion // IAnswerSurveyQuestion<SurveyElementType> Implementation

	}

	#region FreeFormCommand Providers
	partial class ORMInferenceEngineDomainModel
	{
		#region FreeForm Commands for InferredConstraints
		private static IFreeFormCommandProvider<Store> myInferredConstraintsCommands;
		private static IFreeFormCommandProvider<Store> FreeFormInferredConstraintsCommands
		{
			get
			{
				IFreeFormCommandProvider<Store> retVal = myInferredConstraintsCommands;
				if (retVal == null)
				{
					retVal = new InferredConstraintsCommandProvider();
					myInferredConstraintsCommands = retVal;
					retVal = myInferredConstraintsCommands; // Get the current field, but not worth synchronizing
				}
				return retVal;
			}
		}
		private sealed class InferredConstraintsCommandProvider : IFreeFormCommandProvider<Store>
		{
			#region IFreeFormCommandProvider Implementation
			int IFreeFormCommandProvider<Store>.GetFreeFormCommandCount(Store context, object targetElement)
			{
				return 1;
			}
			void IFreeFormCommandProvider<Store>.OnFreeFormCommandStatus(Store context, object targetElement, MenuCommand command, int commandIndex)
			{
				switch (commandIndex)
				{
					case 0:
						command.Visible = true;
						command.Enabled = true;
						((DynamicStatusMenuCommand)command).Text = Resources.InferredConstraints_StartInference_TransactionName;
						break;
				}
			}
			void IFreeFormCommandProvider<Store>.OnFreeFormCommandExecute(Store context, object targetElement, int commandIndex)
			{
				InferenceResult inferenceResult;
				ReadOnlyCollection<InferenceResult> OWLHierarchies = context.ElementDirectory.FindElements<InferenceResult>();
				inferenceResult = (OWLHierarchies.Count == 0) ? new InferenceResult(context) : OWLHierarchies[0];
				if (!inferenceResult.IsDeleted)
				{
					// Add processing for the worker thread.
					BackgroundWorker worker = new BackgroundWorker();
					worker.DoWork += new DoWorkEventHandler(InferenceResultProcessor);
					worker.RunWorkerCompleted += new RunWorkerCompletedEventHandler(ProcessingCompleted);
					inferenceResult.setWorker(worker);
					worker.RunWorkerAsync(inferenceResult);
				}
			}
			public static void ProcessingCompleted(object sender, RunWorkerCompletedEventArgs e)
			{
				Store store;
				InferenceResult contextInferenceResult; // UNDONE: Temporary placeholder for data object, return real data or attach it to ProcessinferenceResult, which is in the sender object
				if (!e.Cancelled &&
					null != (contextInferenceResult = e.Result as InferenceResult) &&
					null != (store = Utility.ValidateStore(contextInferenceResult.Store)) &&
					!contextInferenceResult.IsDeleted)
				{
					contextInferenceResult.setWorker(null);
					Action<InferenceResult> doTransaction = InferenceResult.startInference;
					TransactionManager txMgr = store.TransactionManager;
					// See if we're in a transaction currently and add a temporary TransactionCompleted
					// event handler to process this later.
					if (txMgr.InTransaction)
					{
						EventHandler<TransactionEventArgs> transactionComplete = delegate(object completedSender, TransactionEventArgs txE)
						{
							doTransaction(contextInferenceResult);
						};
						try
						{
							// UNDONE: Not sure if we should run this in transactionCompleted, or in ElementEventsEnded after the
							// transaction is done.
							store.EventManagerDirectory.TransactionCommitted.Add(transactionComplete);
							store.EventManagerDirectory.TransactionRolledBack.Add(transactionComplete);
						}
						finally
						{
							store.EventManagerDirectory.TransactionCommitted.Remove(transactionComplete);
							store.EventManagerDirectory.TransactionRolledBack.Remove(transactionComplete);
						}
					}
					else
					{
						doTransaction(contextInferenceResult);
					}
				}
			}

			#endregion // IFreeFormCommandProvider Implementation
			#region Worker Thread
			private static void InferenceResultProcessor(object sender, DoWorkEventArgs e)
			{
				InferenceResult inferenceResult = (InferenceResult)e.Argument;
				e.Result = inferenceResult;
			}
			#endregion // Worker Thread
		}
		#endregion // FreeForm Commands for InferredConstraints
	}
	#endregion // FreeFormCommand Providers

}
